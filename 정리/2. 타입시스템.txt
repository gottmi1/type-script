- 타입 시스템

컴파일러에게 사용하는 타입을 명시적으로 지정
컴파일러가 자동으로 타입을 추론

타입스크립트 컴파일러는 둘다 가능한데 명시하지 않으면 자동으로 추론함.

★타입은 해당 변수가 할 수 있는 일을 결정한다.

strictNullChekcs 옵션 < 무조건 켜야 함
모든 타입에 자동으로 포함되어있는 null과 undefined를 제거해줌.

예를들어 함수의 인자로 오브젝트를 받을 때, 
function a(b:{name: string, age : number}) {
  ...
}
항상 이렇게 해주는 건 귀찮음.

액션타입에 prefix를 포함한 액션 명을 정의하는 것 처럼 타입스크립트에서도 b를 특정한 타입으로 지정할 수 있다.
interface b {
  ...
}
type bTypeAlias = {
  ...
}

이런 식으로 만들 수 있다



- Structural Type Systme & Nominal Type System

Structural Type Systme - 구조가 같으면 같은 타입으로 취급 typescript에서는 이 시스템을 사용하고 있음.

Nominal Type System - C와 java에서 사용됨
구조가 같아도 이름이 다르다면 다른 타입으로 취급한다.


- 타입 호환성(Type Compatibility)

작은 범주의 타입에는 더 큰 범주의 타입을 넣을 수 없다.
예를들어 타입이 1인 변수는 number타입을 가지는 변수에 넣을 수 있지만 number타입은 1보다 큰 범주이기 때문에 여기에 넣을 수 없음.
같은 논리로 객체를 배열에 넣을 수 없고(배열은 객체의 한 부분이기 때문) 배열을 튜플에 넣을 수 없다(배열이 더 큰 범주이기 때문)

그러나 any는 에러 없이 아무데나 넣을 수 있다.. 쓰지 말자..

클래스를 확장해서 만든 하위 메서드안에 클래스를 넣는 것도 불가능함

1. '같거나 서브타입인 경우', 할당이 가능 => 공변이라고 부름
예르들어 string타입인 변수는 string|number 유니온타입을 가진 변수에 넣을 수 있음.

2. '함수의 매개변수 타입만 같거나 슈퍼타입인 경우' 할당이 가능하다 => 반병이라고 부름
슈퍼타입인 경우란 상속해준 상위 클래스인 경우라고 생각하면 될 것 같다.

strictFunctionTypes 옵션 < 키는 게 좋음
함수를 할당할 시 함수의 매개변수 타입이 같거나 슈퍼타입인 경우가 아닌 경우 에러를 띄움
반병 에러를 방지해 줌


- 타입 별칭(Type Alias)

타입 별명이라고도 부름.
interface와 비슷해보인다.
액션 명을 변수에 할당하는 것 처럼 사용 될 타입을 매번 타이핑 하지않고 미리 만들어놓고 가져다 쓰는 일
유니온 타입 혹은 튜플의 경우 매번 타이핑하기 귀찮고 오타가 있을 수 있기 때문에 별명으로 만드는 경우가 많다.

함수도 알리아싱해주는 경우가 많다.
type EatType = (food : string) => void;

인터페이스와 헷갈릴 수 있다.
명확한 경우 인터페이스를 사용하고, 그냥 여러번 입력하기 귀찮은 경우 알리아스를 사용하는 듯.
크게 차이가 없다고 볼 수도 있겠다.